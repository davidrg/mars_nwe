Index: include/linux/ipx.h
--- linux.org/include/linux/ipx.h	Mon Dec 11 19:55:58 1995
+++ linux/include/linux/ipx.h	Thu Mar 21 17:14:49 1996
@@ -74,5 +74,6 @@
 #define SIOCAIPXITFCRT		(SIOCPROTOPRIVATE)
 #define SIOCAIPXPRISLT		(SIOCPROTOPRIVATE+1)
 #define SIOCIPXCFGDATA		(SIOCPROTOPRIVATE+2)
+#define SIOCIPXNCPCONN		(SIOCPROTOPRIVATE+3)
 #endif
 
Index: include/net/sock.h
Prereq: 	1.0.4	
--- linux.org/include/net/sock.h	Mon Mar 11 02:08:59 1996
+++ linux/include/net/sock.h	Thu Mar 21 02:36:23 1996
@@ -96,6 +96,7 @@
 	ipx_address		dest_addr;
 	ipx_interface		*intrfc;
 	unsigned short		port;
+	unsigned short          ipx_ncp_conn;
 #ifdef CONFIG_IPX_INTERN
 	unsigned char           node[IPX_NODE_LEN];
 #endif
Index: net/ipx/af_ipx.c
--- linux.org/net/ipx/af_ipx.c	Sun Mar 10 22:51:28 1996
+++ linux/net/ipx/af_ipx.c	Thu Mar 21 17:26:54 1996
@@ -438,6 +438,20 @@
 	ipx_socket	*sock1 = NULL, *sock2 = NULL;
 	struct sk_buff	*skb1 = NULL, *skb2 = NULL;
 
+	if (intrfc == ipx_primary_net
+	  && ntohs(ipx->ipx_dest.sock) == 0x451
+	  &&  *((char*)(ipx+1))   == 0x22
+	  &&  *((char*)(ipx+1)+1) == 0x22) {
+	  int connection = (int) *((char*)(ipx+1)+3);
+          /* 255 connections are enough ;) */
+          if (connection) {
+            for (sock1=intrfc->if_sklist;
+		(sock1 != NULL) &&
+		(sock1->protinfo.af_ipx.ipx_ncp_conn != connection);
+		sock1=sock1->next);;
+          }
+        }
+        if (sock1 == NULL)
 	sock1 = ipxitf_find_socket(intrfc, ipx->ipx_dest.sock);
 
 	/*
@@ -1628,6 +1642,7 @@
 		sizeof(sk->protinfo.af_ipx.dest_addr));
 	sk->protinfo.af_ipx.port = 0;
 	sk->protinfo.af_ipx.ncp_server = 0;
+        sk->protinfo.af_ipx.ipx_ncp_conn = 0;     /* no ncp socket yet */
 	sk->mtu=IPX_MTU;
 	
 	if(sock!=NULL)
@@ -2128,6 +2143,17 @@
 			if(err) return err;
 			return(ipxcfg_get_config_data((void *)arg));
 		}
+
+		case SIOCIPXNCPCONN:
+                {
+                  if (!suser()) return(-EPERM);
+                  err = verify_area(VERIFY_READ, (void *)arg,
+                                sizeof(unsigned short));
+                  if (err) return err;
+                  sk->protinfo.af_ipx.ipx_ncp_conn = get_fs_word(arg);
+                  return 0;
+                }
+
 		case SIOCGSTAMP:
 			if (sk)
 			{

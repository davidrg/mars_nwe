diff -rub linux.org/include/linux/ipx.h linux/include/linux/ipx.h
--- linux.org/include/linux/ipx.h	Wed Mar 27 18:43:19 1996
+++ linux/include/linux/ipx.h	Thu Mar 28 11:15:31 1996
@@ -74,5 +74,6 @@
 #define SIOCAIPXITFCRT		(SIOCPROTOPRIVATE)
 #define SIOCAIPXPRISLT		(SIOCPROTOPRIVATE+1)
 #define SIOCIPXCFGDATA		(SIOCPROTOPRIVATE+2)
+#define SIOCIPXNCPCONN		(SIOCPROTOPRIVATE+3)
 #endif
 
diff -rub linux.org/include/net/sock.h linux/include/net/sock.h
--- linux.org/include/net/sock.h	Wed Mar 27 23:05:18 1996
+++ linux/include/net/sock.h	Thu Mar 28 11:15:31 1996
@@ -112,6 +112,10 @@
  * know the connection this socket belongs to. 
  */
 	struct ncp_server       *ncp_server;
+/*
+ * To handle special NCP-Sockets for mars_nwe
+ */
+	unsigned short          ipx_ncp_conn;
 	
 };
 #endif
diff -rub linux.org/net/ipx/af_ipx.c linux/net/ipx/af_ipx.c
--- linux.org/net/ipx/af_ipx.c	Wed Mar 27 17:50:39 1996
+++ linux/net/ipx/af_ipx.c	Thu Mar 28 11:15:31 1996
@@ -448,6 +448,20 @@
 	ipx_socket	*sock1 = NULL, *sock2 = NULL;
 	struct sk_buff	*skb1 = NULL, *skb2 = NULL;
 
+	if (intrfc == ipx_primary_net
+	  && ntohs(ipx->ipx_dest.sock) == 0x451
+	  &&  *((char*)(ipx+1))   == 0x22
+	  &&  *((char*)(ipx+1)+1) == 0x22) {
+	  int connection = (int) *((char*)(ipx+1)+3);
+          /* 255 connections are enough ;) */
+          if (connection) {
+            for (sock1=intrfc->if_sklist;
+		(sock1 != NULL) &&
+		(sock1->protinfo.af_ipx.ipx_ncp_conn != connection);
+		sock1=sock1->next);;
+          }
+        }
+        if (sock1 == NULL)
 	sock1 = ipxitf_find_socket(intrfc, ipx->ipx_dest.sock);
 
 	/*
@@ -1639,6 +1653,7 @@
 		sizeof(sk->protinfo.af_ipx.dest_addr));
 	sk->protinfo.af_ipx.port = 0;
 	sk->protinfo.af_ipx.ncp_server = 0;
+        sk->protinfo.af_ipx.ipx_ncp_conn = 0;     /* no ncp socket yet */
 	sk->mtu=IPX_MTU;
 	
 	if(sock!=NULL)
@@ -2142,6 +2157,17 @@
 			if(err) return err;
 			return(ipxcfg_get_config_data((void *)arg));
 		}
+
+		case SIOCIPXNCPCONN:
+                {
+                  if (!suser()) return(-EPERM);
+                  err = verify_area(VERIFY_READ, (void *)arg,
+                                sizeof(unsigned short));
+                  if (err) return err;
+                  sk->protinfo.af_ipx.ipx_ncp_conn = get_fs_word(arg);
+                  return 0;
+                }
+
 		case SIOCGSTAMP:
 			if (sk)
 			{
